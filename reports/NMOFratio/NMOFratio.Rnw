\documentclass[11pt]{article}

\title{Test Case: Minimising the ratio of two conditional moments}
\author{Enrico
  Schumann\\\footnotesize\href{mailto:es@enricoschumann.net}{\texttt{es@enricoschumann.net}}}
\date{2013-08-01}

% *LANGUAGE/ENCODING*
\usepackage[british]{babel}

% *LAYOUT*
\usepackage[left = 2.5cm,top = 3cm, bottom = 3cm, right = 4.5cm]{geometry}
\renewcommand{\figurename}{Figure}
\usepackage{algorithmic,algorithm}
\usepackage{framed}

% *FONTS*
%\usepackage{mathptmx}
%\usepackage[scaled=0.90]{helvet}
%\usepackage{courier}%
\usepackage{sfourier}
\renewcommand{\rmdefault}{fmnj}
\newcommand{\hy}{{\fontencoding{OT1}\fontfamily{pcr}\selectfont - }}



% soul definition
\usepackage{soul}
\capsdef{T1/ppl/m/n/5-15}{\scshape}{.16em}{.55em}{.2em}

%\newcommand{\Name}[Anzahl]{Definition}
\newcommand{\TA}{\caps{ta}}
\newcommand{\DE}{\caps{de}}
\newcommand{\GA}{\caps{ga}}
\newcommand{\PS}{\caps{ps}}
\newcommand{\R}{\textsf{R}}
\newcommand{\Sfour}{\caps{s}4}
\newcommand{\nmof}{\caps{nmof}}
\newcommand{\gms}{\caps{gms}}

% *MATHS*
\usepackage{amsmath}

% *COLOR/GRAPHICS*
\usepackage{color}
\usepackage{graphics,pst-node,pst-plot,pstricks,pst-fun}
\definecolor{grau2}{rgb}{.2,.2,.2}
\definecolor{grau7}{rgb}{.7,.7,.7}

% *BIB*
\usepackage[round]{natbib}
\usepackage[noae,nogin]{Sweave}
\SweaveOpts{keep.source=TRUE,eps=TRUE,prefix.string=figures/fig}
% *INDEX*
\usepackage{makeidx}\makeindex %\index{xxxx}, \index{xxx!yyy}


% *HYPERREF* settings
\usepackage{hyperref}
\hypersetup{%
colorlinks = false,%
breaklinks = true,%
pdfborder={0 0 0},%
pdftitle={ Minimising the ratio of two conditional moments},%
pdfauthor={Enrico Schumann},%
pdfsubject={finance, heuristic optimisation in finance,%
numerical methods in finance, distributed computing},%
pdfkeywords={finance, heuristic optimisation}}


% define *Sweave* layout
\DefineVerbatimEnvironment{Sinput}{Verbatim}{}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{frame=single,xleftmargin=0em,%
formatcom=\color{grau2},rulecolor=\color{grau7}}
\DefineVerbatimEnvironment{Scode}{Verbatim}{xleftmargin=2em}
\fvset{listparameters={\setlength{\topsep}{0pt}}}
\renewenvironment{Schunk}{\vspace{\topsep}}{\vspace{\topsep}}
<<echo=false>>=
options(continue = " ", digits = 3, width = 65)
@
\begin{document}
\maketitle
\tableofcontents


\section{Test case: Minimising  the ratio of two conditional moments}

We look at a benchmark from the \textsf{Rsolnp} package
\citep{Ghalanos2011}.


We first attach the packages and we change the display options. (The
results are small numbers which would, with a lower \texttt{digits}
setting, all be displayed as \texttt{1}.)
<<>>=
options(digits = 7)
require("Rsolnp")
require("NMOF")
@


We run a benchmark case. 
<<>>=
bmResults <- benchmark(id = "RachevRatio")
strwrap(attr(bmResults, "description"), 0.75 * getOption("width"))
@ 

The aim is to see whether Threshold Accepting (\textsc{ta}) can find
the same solution.  Thus, we define the objective function and the
neighbourhood function for \textsc{ta} (see \citealp{Gilli2001b} for
details).
<<>>=
OF <- function(sol, Data) {
    alpha <- Data$alpha
    Rw <- sol$Rw
    VaRp <- quantile( Rw, probs = alpha, type = 1)
    VaRm <- quantile(-Rw, probs = alpha, type = 1)
    CVaRp <- VaRp - 0.5 * mean(((VaRp - Rw) + abs(VaRp - Rw))) / alpha
    CVaRm <- VaRm - 0.5 * mean(((VaRm + Rw) + abs(VaRm + Rw))) / alpha
    -CVaRm/CVaRp
}

neighbourU <- function(sol, Data){
    wn <- sol$w
    toSell <- wn > Data$winf
    toBuy  <- wn < Data$wsup
    i <- Data$resample(which(toSell), size = 1L)
    j <- Data$resample(which(toBuy),  size = 1L)
    eps <- Data$eps * runif(1)
    eps <- min(wn[i] - Data$winf, Data$wsup - wn[j], eps)
    wn[i] <- wn[i] - eps
    wn[j] <- wn[j] + eps
    Rw <- sol$Rw + Data$R[,c(i,j)] %*% c(-eps,eps)
    list(w = wn, Rw = Rw)
}
@ 

We prepare data and see that our objective function indeed results in
the same values as the benchmark solution.
<<>>=
rets <- as.matrix(dji30ret)
resample <- function(x, ...) 
    x[sample.int(length(x), ...)]

Data <- list(R = rets,
             na = dim(rets)[2L],
             ns = dim(rets)[1L],
             eps = 5/100,
             wsup = 0.1,
             winf = 0,
             alpha = 0.05,
             resample = resample)

## check the objective function:
## (1) get benchmark weights
solnp <- bmResults[grep("par", attr(bmResults, "row.names")), "solnp"]
snopt <- bmResults[grep("par", attr(bmResults, "row.names")), "snopt"]

## (2) setup solutions for TA
sol.solnp <- list(w = solnp, Rw = rets %*% solnp)
sol.snopt <- list(w = snopt, Rw = rets %*% snopt)

## (3) compare objective function values benchmark/OF
bmResults[grep("func", attr(bmResults, "row.names")), ]
data.frame(solnp = OF(sol.solnp, Data),
           snopt = OF(sol.snopt, Data))
@

Run \texttt{TAopt} with an random initial solution and only
1000~iterations.
<<>>=
fun.maker <- function(Data)
    function() {
        ia <- sample.int(Data$na, sample(10:Data$na, 1))
        w0 <- numeric(Data$na)
        w0[ia] <- 1/length(ia)
        list(w = w0, Rw = Data$R %*% w0)        
    }

f0 <- fun.maker(Data)
algo <- list(x0 = f0, neighbour = neighbourU,
             nS = 1L, nT = 1000L, nD = 2000L,
             q = 0.99,
             printBar = FALSE, printDetail = 2000L)
res <- TAopt(OF,algo,Data)
res$OFvalue
@



A path of \textsc{ta}: the current solution in grey, the best-so-far
solution in black.
<<fig=true>>=
plot(cummin(res$Fmat[ ,2L]), type = "l", 
     ylab = "OF value", xlab = "iteration")
lines(res$Fmat[ ,1L], type = 'l', col = grey(.7))
abline(h=c(OF(sol.solnp, Data), OF(sol.snopt, Data)), col = "blue")
@ 

Let us run a number of restarts.
<<fig=true>>=
algo$printDetail <- algo$printBar <- FALSE
algo$nT <- 1000L
restarts <- restartOpt(TAopt, n = 20, OF=OF, algo=algo, Data = Data, 
                       method = "snow", cl = 4)
plot(ecdf(sapply(restarts, `[[`, "OFvalue")), main = "",
     xlim = c(-1.01,-1))

abline(v=c(OF(sol.solnp, Data), OF(sol.snopt, Data)))
@ 

More iterations.
<<fig=true>>=
algo$printDetail <- algo$printBar <- FALSE
algo$nT <- 10000L
restarts <- restartOpt(TAopt, n = 20, OF=OF, algo=algo, Data = Data, 
                       method = "snow", cl = 4)
plot(ecdf(sapply(restarts, `[[`, "OFvalue")), main = "",
     xlim = c(-1.01,-1))
abline(v=c(OF(sol.solnp, Data), OF(sol.snopt, Data)))
@ 

More iterations.
<<fig=true>>=
algo$printDetail <- algo$printBar <- FALSE
algo$nT <- 50000L
restarts <- restartOpt(TAopt, n = 20, OF=OF, algo=algo, Data = Data, 
                       method = "snow", cl = 4)
plot(ecdf(sapply(restarts, `[[`, "OFvalue")), main = "",
     xlim = c(-1.01,-1))
abline(v=c(OF(sol.solnp, Data), OF(sol.snopt, Data)))
@ 

\newpage
\appendix
\section{Resources}

You can download all the book's code examples from the book's home
page,\medskip

\url{http://nmof.net} \bigskip

\noindent The latest version of the \nmof{} package is available
from\medskip

\url{http://enricoschumann.net/R/packages/NMOF/index.htm}\bigskip

\noindent but note that this is the development version. More stable
versions are available from CRAN. \bigskip

\noindent New versions of the package and other news are announced
through the \texttt{NMOF-news} mailing list; to browse the archives or
to subscribe, go to\medskip

\url{https://lists.r-forge.r-project.org/cgi-bin/mailman/listinfo/nmof-news}

\section{Package version}
<<results=tex>>=
toLatex(sessionInfo())
@

\bibliographystyle{plainnat}
\bibliography{Library}


\end{document}
